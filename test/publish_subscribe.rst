Overview
--------

The Publish-Subscribe architecture is a very simplified and decoupled mechanism to
coordinate multiple entities.
In the literature exists numerous variants of this, each one with more or less features.

In our case, this mechanism must fulfill a few requirements:
 - it must allow to communicate multiple processes
 - it must be fast due the expected amount of traffic between the entities

Communication model
-------------------

Exists numerous topologies to implement a Publish-Subscribe communication model.
Our implementation uses the Client - Server topology because its simplicity.
Each entity will be playing the role of the client which can subscribe to and publish
events.
The server will be responsible to keep tracking of which entity is subscribed to which
topic and to receive and redistribute all the published events.

   Currently, the Client - Server communication is implemented using TCP sockets.
   Because all the entities are running in the same machine (there isn't any plan to
   support distributed communication), the TCP channel can be replaced by UNIX sockets
   which are (presumably) more efficient that a TCP socket.

To run the server, 

::

   >>> import os, time
   >>> from subprocess import check_output

   >>> # just an auxiliary function for testing purpose only to know if the process 
   >>> # is running
   >>> def is_running():
   ...   time.sleep(0.01)
   ...   out = check_output(["python", "publish_subscribe/notifier.py", "status"])
   ...   return "running" in out

   >>> os.system("python publish_subscribe/notifier.py start")
   0
   >>> is_running()
   True

The *publish_subscribe* script will spawn the server and will wait until it is ready.

To shutdown the system (only the server, this doesn't affect the clients),

::

   >>> os.system("python publish_subscribe/notifier.py stop")
   0
   >>> is_running()
   False


The server should be able to use the same port again.

::

   >>> os.system("python publish_subscribe/notifier.py start")
   0
   >>> is_running()
   True
   >>> # we let the server running for the rest of this doctest

Entity's API
------------

The API consists of two methods:
 - one method to *subscribe* the entity to some particular event of interest
 - the other method allows to an entity to *publish* some event

   Exist more methods that can be implemented like *unsubscribe*. Currently
   only these two are implemented.

Before any action, the entity must initialize the lib

::
   
   >>> import publish_subscribe.eventHandler 
   >>> pubsub = publish_subscribe.eventHandler.EventHandler()



Subscribe method
----------------

Exist multiple semantics for each method. For example, the *subscribe* method can
have 

 Strong semantic
   after the subscription, the entity will **immediately** receive the correct events.
 
 Weak semantic
   after the subscription, the entity will **eventually** receive the correct events.
   
   **Note:** This distinction hasn't any bibliography.

In the first case, any events that happen right after the subscription will be correctly delivered.
In the second case, the events that happen right after may be are not delivered, only after
a while, the events will be delivered correctly.

The last semantic definition can be used to implement a premature filtering of each
publication. So, if an event hasn't any subscriber, the publish method can drop the event.

   Our implementation uses the *weak* semantic.


To subscribe to an event, the entity must provide a callback to be executed. This
callback will be executed each time that a new event of the correct type reach to the entity.

The callback may run asynchronously in the same thread or in another thread. This
is an implementation detail and the callback should be thread safe.

::

   >>> def foo_handler(event):
   ...   pass
   >>>
   >>> pubsub.subscribe('foo', foo_handler)

Publish method
--------------

The *publish* method also has its details. Two version are commonly used:
 
 Global order
   two events A and B are generated by two distinct entities (first the A event at TA 
   time and then B at TB time),
   then, all the subscribed will receive A and then B. This will happen always no matter
   how much smaller the difference TB-TA be.

 Partial order
   two events A and B are generated by two distinct entities (first the A event, then B)
   if the difference TB-TA is enough, the subscribed will receive A and then B, but
   if the difference is small, then they may receive B and then A.


   The global order impose a stronger condition but at the same time is harder to
   implement, requiring some kind of global clock. 
   The current implementation is designed to run all the entities in the same machine,
   which in that case, the machine's clock can be used. 
   However, the current implementation doesn't use it and only guarantee partial order.

::

   >>> pubsub.publish('bar', "some data")

Events and topics
-----------------

The events can be anything simple like lists, numbers, strings or dictionaries.
Object more complex can be modeled as dictionaries like in Javascript.

The events can be filtered or selected by two mechanisms, by topic or by its content.
Our implementation support only filtering by topic.

::
   
   >>> import threading, time
   >>> shared_list = []
   >>> shared_lock = threading.Lock() # we are using a lock because the
   >>>                                # callback runs in a separeted thread 

   >>> def add_sync(data):
   ...   global shared_lock
   ...   global shared_list
   ...
   ...   shared_lock.acquire()
   ...   shared_list.append(data)
   ...   shared_lock.release()

   >>> pubsub.subscribe('A', add_sync)    # subcribed to the A topic
   
   >>> pubsub.publish('A', "A")
   >>> time.sleep(2) # we wait some time so the event comes back
   >>> shared_list.count("A")
   1

The topic can be seen as a hierarchy of topics.

::

   >>> pubsub.subscribe('B', add_sync)    # subcribed to the B topic but also to any with prefix 'B.'
   >>> pubsub.subscribe('B.C', add_sync)  # subcribed to B.C only

   >>> pubsub.publish('B.C', "B, sub C")
   >>> time.sleep(2) 
   >>> shared_list.count("B, sub C")   # 'B' and 'B.C' called 
   2

   >>> pubsub.publish('B', "just B")
   >>> time.sleep(2) 
   >>> shared_list.count("just B")  # this will be received by only one callbacks
   1

Finally, the *empty* topic means that the subscriber in interested in anything.
It's not possible to publish an event with an *empty* topic.

::


   >>> pubsub.publish('X', "some X event")    # these events will be dropped
   >>> pubsub.publish('W.X.Y.Z', "a very specific event")
   >>> time.sleep(2) 
   >>> shared_list.count("some X event"), shared_list.count("a very specific event")
   (0, 0)
   
   >>> pubsub.subscribe('', add_sync) 

   >>> pubsub.publish('X', "some X event")
   >>> pubsub.publish('W.X.Y.Z', "a very specific event")
   >>> time.sleep(2) 
   >>> shared_list.count("some X event"), shared_list.count("a very specific event")
   (1, 1)


Only letters, digits, underscores, dashes and dots are the only valid characters.
Dots split the topics into subtopics and they cannot be used at the start or the
end of the topic neither can be two or more consecutive.

::

   >>> pubsub.publish('X Y', 'xxx')          # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.publish('X.', 'xxx')           # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.publish('.X', 'xxx')           # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.publish(' ', 'xxx')            # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.publish('xy..z', 'xxx')        # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...


These rules apply to the subscriptions too:

::

   >>> pubsub.subscribe('X Y', lambda: 0)          # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe('X.', lambda: 0)           # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe('.X', lambda: 0)           # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe(' ', lambda: 0)            # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe('xy..z', lambda: 0)        # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

The only difference is in the *empty topic*. The subscription to the *empty topic*
means that the entity is interested in *any* event.
Publish *any* event make no senses.

::

   >>> pubsub.publish('', 'xxx')        # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe('', lambda: 0)  # no exception here


Don't forget to close the connection and stop the server.

::

   >>> pubsub.close()
   >>>
   >>> os.system("python publish_subscribe/notifier.py stop")
   0
   >>> is_running()
   False
