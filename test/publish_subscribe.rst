Overview
--------

The Publish-Subscribe architecture is a very simplified and decoupled mechanism to
coordinate multiple entities.
In the literature exists numerous variants of this, each one with more or less features.

In our case, this mechanism must fulfill a few requirements:
 - it must allow to communicate multiple processes
 - it must be fast due the expected amount of traffic between the entities

Communication model
-------------------

Exists numerous topologies to implement a Publish-Subscribe communication model.
Our implementation uses the Client - Server topology because its simplicity.
Each entity will be playing the role of the client which can subscribe to and publish
events.
The server will be responsible to keep tracking of which entity is subscribed to which
topic and to receive and redistribute all the published events.

   Currently, the Client - Server communication is implemented using TCP sockets.
   Because all the entities are running in the same machine (there isn't any plan to
   support distributed communication), the TCP channel can be replaced by UNIX sockets
   which are (presumably) more efficient that a TCP socket.

To run the server, 

::

   >>> import os, time
   >>> from subprocess import check_output

   >>> # just an auxiliary function for testing purpose only to know if the process 
   >>> # is running
   >>> def is_running():
   ...   time.sleep(0.01)
   ...   out = check_output(["python", "py/publish_subscribe/notifier.py", "status"])
   ...   return "running" in out

   >>> os.system("python py/publish_subscribe/notifier.py start")
   0
   >>> is_running()
   True

The *publish_subscribe* script will spawn the server and will wait until it is ready.

To shutdown the system (only the server, this doesn't affect the clients),

::

   >>> os.system("python py/publish_subscribe/notifier.py stop")
   0
   >>> is_running()
   False


The server should be able to use the same port again.

::

   >>> os.system("python py/publish_subscribe/notifier.py start")
   0
   >>> is_running()
   True
   >>> # we let the server running for the rest of this doctest

Entity's API
------------

The API consists of two methods:
 - one method to *subscribe* the entity to some particular event of interest
 - the other method allows to an entity to *publish* some event

   Exist more methods that can be implemented like *unsubscribe*. Currently
   only these two are implemented.

Before any action, the entity must initialize the lib

::
   
   >>> import publish_subscribe.eventHandler 
   >>> pubsub = publish_subscribe.eventHandler.EventHandler()



Subscribe method
----------------

Exist multiple semantics for each method. For example, the *subscribe* method can
have 

 Strong semantic
   after the subscription, the entity will **immediately** receive the correct events.
 
 Weak semantic
   after the subscription, the entity will **eventually** receive the correct events.
   
   **Note:** This distinction hasn't any bibliography.

In the first case, any events that happen right after the subscription will be correctly delivered.
In the second case, the events that happen right after may be are not delivered, only after
a while, the events will be delivered correctly.

The last semantic definition can be used to implement a premature filtering of each
publication. So, if an event hasn't any subscriber, the publish method can drop the event.

   Our implementation uses the *weak* semantic.


To subscribe to an event, the entity must provide a callback to be executed. This
callback will be executed each time that a new event of the correct type reach to the entity.

The callback may run asynchronously in the same thread or in another thread. This
is an implementation detail and the callback should be thread safe.

::

   >>> def foo_handler(event):
   ...   pass
   >>>
   >>> pubsub.subscribe('foo', foo_handler)

Publish method
--------------

The *publish* method also has its details. Two version are commonly used:
 
 Global order
   two events A and B are generated by two distinct entities (first the A event at TA 
   time and then B at TB time),
   then, all the subscribed will receive A and then B. This will happen always no matter
   how much smaller the difference TB-TA be.

 Partial order
   two events A and B are generated by two distinct entities (first the A event, then B)
   if the difference TB-TA is enough, the subscribed will receive A and then B, but
   if the difference is small, then they may receive B and then A.


   The global order impose a stronger condition but at the same time is harder to
   implement, requiring some kind of global clock. 
   The current implementation is designed to run all the entities in the same machine,
   which in that case, the machine's clock can be used. 
   However, the current implementation doesn't use it and only guarantee partial order.

::

   >>> pubsub.publish('bar', "some data")

Events and topics
-----------------

The events can be anything simple like lists, numbers, strings or dictionaries.
Object more complex can be modeled as dictionaries like in Javascript.

The events can be filtered or selected by two mechanisms, by topic or by its content.
Our implementation support only filtering by topic.

::
   
   >>> import threading, time
   >>> shared_list = []
   >>> shared_lock = threading.Lock() # we are using a lock because the
   >>>                                # callback runs in a separeted thread 

   >>> def add_sync(data):
   ...   global shared_lock
   ...   global shared_list
   ...
   ...   shared_lock.acquire()
   ...   shared_list.append(data)
   ...   shared_lock.release()

   >>> pubsub.subscribe('A', add_sync)    # subcribed to the A topic
   
   >>> pubsub.publish('A', "A")
   >>> time.sleep(2) # we wait some time so the event comes back
   >>> shared_list.count("A")
   1

The topic can be seen as a hierarchy of topics.

::

   >>> pubsub.subscribe('B', add_sync)    # subcribed to the B topic but also to any with prefix 'B.'
   >>> pubsub.subscribe('B.C', add_sync)  # subcribed to B.C only

   >>> pubsub.publish('B.C', "B, sub C")
   >>> time.sleep(2) 
   >>> shared_list.count("B, sub C")   # 'B' and 'B.C' called 
   2

   >>> pubsub.publish('B', "just B")
   >>> time.sleep(2) 
   >>> shared_list.count("just B")  # this will be received by only one callbacks
   1

The matching is hierarchal, from the left to the right.

::

   >>> pubsub.subscribe('red.Z', add_sync)
   >>> pubsub.subscribe('blue.Z', add_sync)

   >>> pubsub.publish('green.Z', 'green') # don't care th *.Z, we start the matching from the left
   >>> time.sleep(2)
   >>> shared_list.count('green') 
   0


Finally, the *empty* topic means that the subscriber in interested in anything.
It's not possible to publish an event with an *empty* topic.

::


   >>> pubsub.publish('X', "some X event")    # these events will be dropped
   >>> pubsub.publish('W.X.Y.Z', "a very specific event")
   >>> time.sleep(2) 
   >>> shared_list.count("some X event"), shared_list.count("a very specific event")
   (0, 0)
   
   >>> pubsub.subscribe('', add_sync) 

   >>> pubsub.publish('X', "some X event")
   >>> pubsub.publish('W.X.Y.Z', "a very specific event")
   >>> time.sleep(2) 
   >>> shared_list.count("some X event"), shared_list.count("a very specific event")
   (1, 1)


Only letters, digits, underscores, dashes and dots are the only valid characters.
Dots split the topics into subtopics and they cannot be used at the start or the
end of the topic neither can be two or more consecutive.

::

   >>> pubsub.publish('X Y', 'xxx')          # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.publish('X.', 'xxx')           # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.publish('.X', 'xxx')           # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.publish(' ', 'xxx')            # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.publish('xy..z', 'xxx')        # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...


These rules apply to the subscriptions too:

::

   >>> pubsub.subscribe('X Y', lambda: 0)          # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe('X.', lambda: 0)           # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe('.X', lambda: 0)           # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe(' ', lambda: 0)            # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe('xy..z', lambda: 0)        # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

The only difference is in the *empty topic*. The subscription to the *empty topic*
means that the entity is interested in *any* event.
Publish *any* event make no senses.

::

   >>> pubsub.publish('', 'xxx')        # doctest: +ELLIPSIS
   Traceback (most recent call last):
   Exception: ...

   >>> pubsub.subscribe('', lambda: 0)  # no exception here

Subscription object
-------------------

Each call to *subscribe* generate a subscription, each one has an unique id which
is returned by the *subscribe* call if you request it.
The subscription object can be accessed as an attribute of the callback when
is executed.

If one callback is registered multiple times, in each execution the correct subscription
object will be setted in the *subscription* property of the callback.

::

   >>> results = []

   >>> def f(data):
   ...    global results
   ...    results.append((data, f.subscription['id']))

   >>> subscription_id_1 = pubsub.subscribe('subcription-object-1', f, return_subscription_id=True)
   >>> subscription_id_2 = pubsub.subscribe('subcription-object-2', f, return_subscription_id=True)

   >>> pubsub.publish('subcription-object-1', 'A')
   >>> pubsub.publish('subcription-object-2', 'B')

   >>> time.sleep(2)
   >>> results = zip(*results)  # [(a, 1), (b, 2)] --> [(a, b), (1, 2)]

   >>> results[0] 
   (u'A', u'B')

   >>> results[1] == (subscription_id_1, subscription_id_2)
   True


Unsubscription
--------------

In some cases it's necessary to cancel a subscription.
Each subscription has a identifier that you can use to cancel it latter.

::

   >>> receive = None
   >>>
   >>> def f(data):
   ...    global receive
   ...    receive = data

   >>> subscription_id = pubsub.subscribe('to-be-cancel', f, return_subscription_id=True)
   >>>
   >>> pubsub.publish('to-be-cancel', 'A')
   >>> time.sleep(2)

   >>> pubsub.unsubscribe(subscription_id)
   >>> pubsub.publish('to-be-cancel', 'B') #this event should be discarted.

   >>> time.sleep(2)
   >>> receive
   u'A'


One time Subscription
---------------------

Sometimes you are only interested in one particular event and not in all the events 
of some topic.
This kind of subscription for just one is a shortcut of:

::

   >>> received = None
   >>> def called_only_one(data):
   ...   global received
   ...   received = data
   ...
   ...   pubsub.unsubscribe(called_only_one.subscription['id'])

   >>> pubsub.subscribe('only-one', called_only_one)

   >>> pubsub.publish('only-one', 'A')
   >>> pubsub.publish('only-one', 'B')

   >>> time.sleep(2)
   >>> received
   u'A'

The *subscribe_for_once_call* is a shortcut for that:

::

   >>> received = None
   >>> def called_only_one(data):
   ...   global received
   ...   received = data

   >>> pubsub.subscribe_for_once_call('only-one', called_only_one)

   >>> pubsub.publish('only-one', 'A')
   >>> pubsub.publish('only-one', 'B')

   >>> time.sleep(2)
   >>> received
   u'A'
   

Cleanup
-------

Don't forget to close the connection and stop the server.

::

   >>> pubsub.close()
   >>>
   >>> os.system("python py/publish_subscribe/notifier.py stop")
   0
   >>> is_running()
   False

Reconnections and duplicated messages
-------------------------------------

If a established connection was suddenly closed, two options are possible:
 - reconnect and send the message again.
 - throw an error

The first approach is the more elaborated but implies that if a message was sent and
the connection is closed immediately, the client should reconnect and *resend* the
messages which can lead to duplicated messages and/or to dropped messages due the 
lack of any acknowledge.

The second approach is safer but simplistic.

We currently support only the second approach, in case that a connection is closed, we
*throw an error*. The only exception is when the client connects to the server for the
first time. In that case we attempt several times the connection (and this is safe because
we don't sent any message, so there is no way to duplicate or drop any message).

::

   >>> is_running()
   False
   >>> os.system("( sleep 5 && python py/publish_subscribe/notifier.py start ) &")
   0
   >>> is_running()  # yes, it should not be running right now.
   False

   >>> pubsub = publish_subscribe.eventHandler.EventHandler() # we block until the server is ready (or timeout)
   >>> is_running()  # now it should be running
   True
   
   >>> pubsub.close()
   >>> os.system("python py/publish_subscribe/notifier.py stop")
   0

Javascript's API
----------------

We provide the same API implemented in Javascript too.
First we initialize the object

::

   >>> os.system("( sleep 1 && python py/publish_subscribe/notifier.py start ) &")
   0
   >>> is_running()  # yes, it should not be running right now.
   False

::

   js> var pubsub = new event_handler.EventHandler();
   js> pubsub.init();            // this method is NOT blocked

-------------------------------------------------------------------------------

.. note:: There is a bug in the Javascript API that if the connection in the *init* fails, 
   the subsequents calls to *publish* and *subscribe* will trigger a **core dump** in
   the javascript server. Any action **must** be executed after the API is connected.

   ::

      >>> time.sleep(3)    # workaround!!!
      >>> is_running()
      True

-------------------------------------------------------------------------------

   
Then we can subscribe to any event
(Note: the callback will not have a 'subcription' property like the callbacks in Python)

::

   js> var result = {}
   js> pubsub.subscribe('baz', function (data) {
   ...   result.baz_data = data;
   ... });
   0
   js> pubsub.subscribe('baz.dac', function (data) {
   ...   result.dac_data = data;
   ... });
   1
   js> pubsub.subscribe('', function (data) {
   ...   result.any_data = data;
   ... });
   2

And, of course, we can receive and/or send events

::
   
   js> pubsub.publish('baz', 'some data of baz');

   js> var count = 0;   // ugly "bussy wait" to wait for the event
   js> while ( !result.baz_data && count < 10000 ) { count += 1; } ; result.baz_data; 
   'some data of baz'

   js> result.any_data === result.baz_data; // 'any' callback was called
   true

::

   js> pubsub.publish('baz.dac', 'some data of baz.dac but the data is baz too');

   js> var count = 0;   
   js> while ( !result.dac_data && count < 10000 ) { count += 1; } ; result.dac_data; 
   'some data of baz.dac but the data is baz too'
   
   js> result.baz_data === result.dac_data; // the 'baz' callback is called too when the event is 'baz.*'
   true
   js> result.any_data === result.dac_data; // 'any' callback was called too
   true

The API support unsubscribe callbacks, first subscribe the callback as usual *but* save
the subscription id returned (this is the default, unlike the Python version that you
need to explicity request it).

::
   
   js> var subscription = pubsub.subscribe('temporal', function (data) {
   ...   result.tmp_data = data;
   ... });

To unsubscribe:

::

   js> pubsub.unsubscribe(subscription);

To prove this, we send a 'temporal' event and it should not be received

::

   js> result.tmp_data = "no data for now";
   'no data for now'

   js> pubsub.publish('temporal', 'this should not be received');

   js> var count = 0;   
   js> while ( count < 10000 ) { count += 1; } ; result.tmp_data;
   'no data for now'


We support also the *subscribe_for_once_call* too:

::

   js> var result = {}
   js> var _ = pubsub.subscribe_for_once_call('temporal-once', function (data) {
   ...   result.tmp_data = data;
   ... });

   js> result.tmp_data = "no data for now";
   'no data for now'

   js> pubsub.publish('temporal-once', 'this should be received');
   js> pubsub.publish('temporal-once', 'this should NOT be received');

   js> var count = 0;
   js> while ( count < 10000 ) { count += 1; } ; result.tmp_data;
   'this should be received'
   
Finally, we close and release any resource

::

   js> pubsub.close();
   
   >>> os.system("python py/publish_subscribe/notifier.py stop")
   0
   >>> is_running()
   False
